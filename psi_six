"""
Psi 6 is a method for calculating how close to perfectly hexagonal a crystal arrangment is 
"""
import numpy as np
from scipy.spatial import cKDTree
import matplotlib.pyplot as plt
from scipy.spatial import Delaunay
import time 

def read_better(file):
    coordinates=[]
    with open("dump.LJ", "r") as f:
        lines =f.readlines()
        for i in range(1,102):
            index1 = i*1009 +9 
            index2 = index1 + 1000
            set1 = []
            atom_positions = lines[index1:index2]
            for atom in atom_positions:
                data =atom.split()
                x, y = float(data[2]), float(data[3])
                set1.append([x,y])
            coordinates.append(np.array(set1, dtype=float))
            
    return np.array(coordinates, dtype=object)


def read_data(filename):
    coordinates=[]

    with open(filename, "r") as f:
        lines = f.readlines() # opens the output file and reads the each line as an item in a list of strings
    
    #extract the data for the positions 
    atom_positions = lines[9:1009]
    for atom in atom_positions:
        data =atom.split()
        x, y = float(data[2]), float(data[3])
        coordinates.append([x,y])

    return np.array(coordinates)

def scale_limit(coordinates):
    tree = cKDTree(coordinates, boxsize=None)
    distances, indices = tree.query(coordinates, k=7, workers=1)
    neighbors = indices[:, 1:]
    distances = distances[:, 1:]
    a = np.median(distances[:,5])
    limit = 1.1 * a
    return limit

def Number_near_neighbour (coordinates, limits=1.2, k=6):
    """
    works by taking a paricle and first the 6 closest neighbour
    start from a     small mod (R) and make it slowly bigger, have a tollarance and stop when you get 6 in a regestatly
    """
    #N = len(coordinates)

    tree = cKDTree(coordinates, boxsize=None)
    #qyery the tree to find a list of distances for nearest neighbors 
    #set workers=-1 is you do a batch job with more then one CPU, (-1 uses all available CPU's)
    #distances, indices = tree.query(coordinates, k=k+1, workers=1)

    #don't include the particle you are queiring, first element will be 0 for distance 
    #neighbors = indices[:, 1:]
    #distances = distances[:, 1:]

    # this calculates near neighbors witha cut off of 1.3 * a 
    Neighbors = tree.query_ball_point(coordinates,r=limits)
    # count, number of neighbours for each atom, used in coloured vmd
    count =[]
    #a way to count the number of near neighbors for each atom i 
    for i in range(len(Neighbors)):
        if i in Neighbors[i]:
         #if particle 10 is in the list of neighbors for 10 then remove it
         Neighbors[i].remove(i)

        count.append(len(Neighbors[i]))

    return Neighbors, count

def Number_near_neighbout_delinea(coordinates):
    tri = Delaunay(coordinates)
    triangles = tri.simplices
    thres =3.0

    def circumradius(try_pts):
        a = np.linalg.norm(try_pts[0]-try_pts[1])
        b = np.linalg.norm(try_pts[1]-try_pts[2])
        c = np.linalg.norm(try_pts[2]-try_pts[0])
        s = 0.5*(a+b+c)
        area = max(s*(s-a)*(s-b)*(s-c),0.0)**0.5
        if area == 0: return np.inf
        return (a*b*c)/(4.0*area)    
    # Perform Delaunay triangulation

    # Filter out triangles whose circumradius is too large
    triangles = tri.simplices
    tri_radii = np.asarray([circumradius(coordinates[t,:]) for t in triangles])
    med_radius = np.median(tri_radii)
    thres *= med_radius
    triangles = triangles[tri_radii < thres]

    # Create the neighbour lists - only consider the filtered triangles based on
    # the threshold on circumradius
    neighbours = [set() for i in range(len(coordinates))]
    for s in triangles:
        for i in s:
            for j in s:
                if (i != j):
                    neighbours[i].add(j)
    # Convert sets to sorted lists
    neighbours = [list(s) for s in neighbours]
    count = [len(s) for s in neighbours]
    return neighbours, count


def angles_for_NN(coordinates, neighbors):
    angles =[]
    for i in range(len(coordinates)):
        #for each atom find the 5 angles that make up the hexagonal strucutre and add it to a list  
        #atom i
        xi, yi = coordinates[i]
        # near neiborours for atom i (already sorted)
        Nn = np.array(coordinates[neighbors[i]], dtype=float)
        #compure vecotrs from atom i to near neibours 
        #and normalise 
        vectors = Nn - np.array([xi,yi], dtype=float)
        norms = np.linalg.norm(vectors,axis=1, keepdims=True)
        norms[norms == 0] = 1.0 
        vectors = vectors /norms

        #now compute all 6 anlges around one atom  
        angles_for_atomi =[]
        for A in vectors:
            theta = np.arctan2(A[1], A[0]) 
            angles_for_atomi.append(theta)
        # append atom i's 6 angle to a master list for all atoms 
        angles.append(angles_for_atomi)
    return angles



def psi_six_local_order(angles):
    "takes angles and nearest neighbour and returns psi 6 value"
    psi = []
    for angle_list in angles:
        psi_i = 0 
        for x in angle_list: 
            exponential = np.exp(6j*x)
            psi_i += exponential
        psi.append(psi_i/len(angle_list))

    return np.array(psi)

def psi_six_global(local,N):
    "golbal version "
    psi = np.abs(np.mean(local))
    return psi

def psi_six_global2(local,N):
    return np.mean(np.abs(local))


def vmd_file_wrier(coordinates, count):

    with open("vmd_input.xyz", "w") as f:
        f.write(f"{len(coordinates)}\n")
        f.write(f"atoms\n")
        for i , (x,y) in enumerate(coordinates):
            atom_type = count[i]  
            f.write(f"{i} {atom_type} {x:.7f} {y:.7f} 0.5\n")
    
def plot(coordinates):
    """
    plot of psi 6 over interations of lammps simulation 
    """
    psi_per_time=[]

    for i in range(len(coordinates)):
        start=time.time()

        near_neighbours, count = Number_near_neighbout_delinea(coordinates[i])

        anlge_input = angles_for_NN(coordinates[i], near_neighbours)
        N = len(coordinates[i])
        psi= psi_six_local_order(anlge_input)

        psi_global = psi_six_global(psi,N)
        psi_global2 = psi_six_global2(psi,N)
        psi_per_time.append(psi_global2)
        end = time.time()
        elapsed = end - start
        print(f" psi 6 is {psi_global2:.4f}, time taken {elapsed:.2f} seconds")
        return psi_per_time

def redisdulas(time_step):
    "r = psi(t) - psi(t-1)  || this is the result of np.diff"
    time_step = np.array(time_step)
    r = np.diff(time_step, axis=0)
    plt.plot(r)
    plt.xlabel("iterations of lammps simulation")
    plt.ylabel("residual value")
    plt.title("residual plot for psi 6 simulation")

    plt.show()

def main():
    coordinates = read_better("dump.LJ")

    limit = scale_limit(coordinates[-1])
    psi_per_time = plot(coordinates)
    #results for the last time step taken seperatly     
    near_neighbours, count = Number_near_neighbour(coordinates[-1], limits=limit)
    nn, cc = Number_near_neighbout_delinea(coordinates[-1])
    print(f"mean count for tree is {np.mean(count):.2f}, mean count for delaunay is {np.mean(cc):.2f}")
    #ckdtree method 
    anlge_input = angles_for_NN(coordinates[-1], near_neighbours)
    N = len(coordinates[-1])
    psi= psi_six_local_order(anlge_input)

    psi_global = psi_six_global(psi,N)
    psi_global2 = psi_six_global2(psi,N)
    print(f"the tree average is {psi_global2}")
    #delinea
    anlge_input2 = angles_for_NN(coordinates[-1], nn)
    N = len(coordinates[-1])
    psi2= psi_six_local_order(anlge_input2)


    psi_global3 = psi_six_global2(psi2,N)
    print(f"the delinea psi is {psi_global3}")


    # plot for elequilibriation 
    vmd_file_wrier(coordinates[-1],count)

    x = np.arange(len(psi_per_time))

    plt.plot(x , psi_per_time)
    plt.xlabel("time steps")
    plt.ylabel("psi 6")
    plt.title("Plot")
    plt.show() 
    #print(f"The Psi 6 local value is {np.abs(psi)}")

    print("-----------------------------")
    print(f"The global value for psi 6 is .. {psi_per_time[-1]}")


if __name__ == "__main__":
    main()